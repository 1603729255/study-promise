<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    /*
      let p1 = new Promise((resolve, reject) => {
        // 1 resolve函数
        // resolve("OK");
        //2 reject 函数
        // reject("error");
        //3 抛出错误
        throw "出问题了";
      });
    
      console.log(p1);
     */

    /* // p2指定多个回调 在状态改变时都会执行。状态不改变 都不执行
      let p2=new Promise((resolve, reject) => {
        resolve('ok')
      })
    
      p2.then(value=>{
        console.log(1,value);
      })
      p2.then(value=>{
        console.log(2,value);
      }) 
    */

    /* 
      // resolve("ok2");先改变状态再指定并执行回调
      // resolve("ok1");由于在异步的setTimeout中,会先执行then指定回调,等到resolve执行再执行函数
      // then会放入微任务队列中
    
      let p3 = new Promise((resolve, reject) => {
        setTimeout(() => {
          console.log(1);
          resolve("ok1");
        }, 2000);
        // resolve("ok2");
      });
    
      p3.then(
        (value) => {
          console.log(value);
        },
        (reason) => {}
      );
    */

    /*    
      // then的返回值是哪一个
      let p4 = new Promise((resolve, reject) => {
        resolve("ok");
      });
      let result4 = p4.then(value => {
        // throw '抛出问题'
        // return '返回非promise对象'
        // promise 对象 那么result4得到最近的那个返回
        return new Promise((resolve, reject) => {
          resolve("OK")
        })

      }, reason => {
        console.log(reason);
      })
      console.log(result4); 
    */


    /*
      // then返回一个promise,链式调用。错误可以再最后处理
      let p5 = new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve('ok')
        }, 1000);
      })

      p5.then(value=>{
        return new Promise((resolve, reject) => {
          resolve('success')
        })
      }).then(value=>{
        console.log(value);
        // 中断promise链 返回pending状态的promise
        return new Promise(()=>{})
      }).then(value=>{
        console.log(value);
      }).catch(reason=>{
        console.warn(reason)
      }) 
    */


    
  </script>
</body>

</html>
